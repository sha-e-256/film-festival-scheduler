#!/usr/bin/env python3

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as ec
from webdriver_manager.firefox import GeckoDriverManager
from festival import Film, Screening, User
from datetime import date, datetime, timedelta
import pickle
import os
from collections import defaultdict
import itertools
from typing import List, Generator

def get_user_film_dict(film_list: list[Film]) -> defaultdict:
    user_film_dict = defaultdict(set)
    while True:
        upper_bound = len(film_list)
        try:
            user_film_index = int(input(f'Enter a number 1 to {upper_bound} (Enter -1 to exit): '))
            # Validate input
            if user_film_index in range(1, upper_bound + 1):
                user_film_dict[user_film_index - 1] = film_list[user_film_index - 1]
                # usr_film_list is a set so not duplicates will be added
                print(f'Added film {film_list[user_film_index - 1].film_name} to watchlist.')
            elif user_film_index == -1:
                break
            else:
                print('Invalid input. Please try again.')
        except ValueError:
            print('Invalid input. Please try again')

    return user_film_dict

def get_user_date_dict(date_list: List[date]) -> defaultdict:
    user_date_dict = defaultdict(set)
    while True:
        upper_bound = len(date_list)
        try:
            user_date_index = int(input(f'Enter a number 1 to {upper_bound} (Enter -1 to exit): '))
            # Validate input
            if user_date_index in range(1, upper_bound + 1):
                user_date_dict[user_date_index - 1] = date_list[user_date_index - 1]
                print(f'Added date {date_list[user_date_index - 1]}.')
            elif user_date_index == -1:
                break
            else:
                print('Invalid input. Please try again.')
        except ValueError:
            print('Invalid input. Please try again')

    return user_date_dict

def date_generator() -> Generator[date, None, None]:
    start_date = date(2022, 10, 27)
    end_date = date(2022, 11, 6)
    delta = timedelta(days=1)  # Increment iteration by one day
    while (start_date <= end_date):
        yield start_date
        start_date += delta

def print_date_list(date_list: List[date]) -> None:
    for index, date in enumerate(date_list):
        print(f'[{index+1:03d}]: {date}')

def get_date_list() -> List[date]:
    date_list = []
    for date in date_generator():
        date_list.append(date)
    return date_list

def print_film_list(film_list: list[Film]) -> None:
    for index, film in enumerate(film_list):
        print(f'[{index+1:03d}]: {film.film_name}')
        # 03d: 3 digits pad with zeros

def save_film_list(film_list: list[Film], dst_file_name: str) -> None:

    with open(file=dst_file_name, mode="wb") as file:
        pickle.dump(obj=film_list, file=file)
        file.close()

def load_film_list(src_file_name: str) -> list[Film]:

    with open(file=src_file_name, mode="rb") as file:
        film_list = pickle.load(file=file)
    file.close()
    return film_list

def generate_film_list(file_name: str) -> defaultdict:
    film_dict = defaultdict(set)  # Create a list of Film objects
    screening_dict = defaultdict(set)  # Create a list of Screening objects
    
    browser = webdriver.Firefox(executable_path=GeckoDriverManager().install())
    browser.get('https://windsorfilmfestival.com/')
    film_list_button = browser.find_element(by=By.PARTIAL_LINK_TEXT,
                                    value='Films & Tickets')
    film_list_button.click()

    # After clicking, wait 1 s (5000 ms) for the site to load
    # Locator accepts a tuple as an arguement
    film_data_list = WebDriverWait(browser,
                                   1999).until(ec.presence_of_all_elements_located(locator=(By.XPATH,
                                                                                            "//div[@class='film-content']")))
    for film_data_index, film_data in enumerate(film_data_list):
        film_name_element = film_data.find_element(by=By.XPATH,
                                        value="./h2")  # . searches the child of
                                                       # the current node
        film_name = film_name_element.text
        screening_list = film_data.find_elements(by=By.XPATH,
                                                    value=".//div[@class='film-screen']")
        for screening_index, screening in enumerate(screening_list):
            screening_str = screening.text
            screening_str_list = screening_str.split('\n')
            
            screening_start_time_str = film_screen_str_list[-1]
            screening_start_time = datetime.strptime(screening_start_time_str, 
                                                     '%I:%M %p')
            
            film_length = 100  # Hardcode for now
            
            screening_end_time = screening_start_time + timedelta(minutes=film_length)
            
            screening_date_str = screening_str_list[0]
            screening_date = datetime.strptime(screening_date_str,
                                        '%a %b %d').date()  
            # Year defaults to 1899; change to 2022
            screening_date_correct_year = screening_date.replace(2021)
            
            screening_location = screening_str_list[1]

            # Make a Screening object
            curr_screening = Screening(screening_start_time,
                                    screening_end_time,
                                    screening_date_correct_year,
                                    screening_location)
            screening_dict[screening_index] = curr_screening

        # Make a Film object
        curr_film = Film(film_name, screening_dict)
        film_dict[film_data_index] = curr_film
        screening_dict.clear()  # Empty the dict of screenings
        
        '''
        moreInfo_button = filmData.find_element(by=By.PARTIAL_LINK_TEXT,
                                                value='MORE INFO')
        moreInfo_button.click()
        film_extras = WebDriverWait(browser, 4999).until(ec.presence_of_all_elements_located(locator=(By.XPATH,
                                                                                                            "//div[@class='film-extras']")))
        film_extras_str = film_extras[-1].text
        film_length = film_extras_str.split('\n')[-2]
        '''
    browser.quit()
    return film_dict

def print_film_dict(film_dict: defaultdict(set)) -> None:
    # Print all the values that yield from the generator
    print('\n--Watchlist:--\n')
    [print(film.film_name) for film in film_dict.values()]

def convert_film_dict_to_list(films_dict: defaultdict(set)) \
    -> List[List[tuple[str, Screening]]]:
    '''
    Convert the dict into a list of tuples such that each tuple contains
    the name of the film, and the Screening object; this is done so that the
    name of the film that a Screening belongs to is preserved after the
    cartesian product is generated.
    '''
    films_tuples = []
    # Each tuple contains the film name and one screening
    for film in films_dict.values():
        film_screenings_tuples = [(film.film_name, film_screening) \
                                  for film_screening in film.film_screenings]
        films_tuples.append(film_screenings_tuples)
    return films_tuples

def create_unique_film_list(films_tuples: List[List[tuple[str, Screening]]]) \
    -> List[tuple[tuple[str, Screening]]]:
    '''
    Return the set of all ordered tuples such that each set only contains
    one screening for each movie.
    '''
    # This method a list of tuples of tuples; not a list of lists ruples
    unique_films_tuples = list(itertools.product(*films_tuples))
    return unique_films_tuples

def print_unique_films_tuples(unique_films_tuples: \
    List[list[tuple[str, Screening]]]) -> None:
    print('\n--Watchlist with Optimal Viewing Schedule:--\n')
    for i, combination in enumerate(unique_films_tuples):
        print(f'--Combination {i + 1}--\n')
        for film in combination:
            print(f'''\
Film Name: {film[0]}
Film Screening: {film[1].__str__()}
            ''')

def sort_combination_by_start_time(unique_films_tuples: \
    List[tuple[tuple[str, Screening]]]) -> List[List[tuple[str, Screening]]]:
    '''
    Sort the combination of films in the list of film tuples by the
    start time of the screenings.
    '''
    sorted_unique_film_tuples = []
    for combination in unique_films_tuples:
        combination_list = list(combination)
        # Sort each combination based off of the screening's start time
        combination_list.sort(key=lambda x: x[1].screening_time_start)
        sorted_unique_film_tuples.append(combination_list)
    return sorted_unique_film_tuples

def get_optimal_watchlist(sorted_unique_film_tuples: List[List[tuple[str, Screening]]]) \
    -> List[List[tuple[str, Screening]]]:
    '''
    Return all combinations of films with non-overlapping intervals
    '''
    for combination in sorted_unique_film_tuples:
        # Start at the first tuple in the combination list
        # The second element in the tuple is the Screening object
        prev_end = combination[0][1].screening_time_end
        # Compare current tuple against the rest of the tuples
        index = 0
        for film_tuple in combination[1:]:
            start_time, end_time = (film_tuple[1].screening_time_start,
                                   film_tuple[1].screening_time_end)
            # Check if the next film starts after the first film
            # If the movies are on different dates; they definitely do not overlap
            if start_time >= prev_end or film_tuple[1].screening_date != combination[index][1].screening_date:
                prev_end = end_time  # No overlap; check the next film
            # The next film DOES start after the first film; i. e. overlap detected
            else:
                combination.remove(film_tuple)  # This movie is causing an overlap
                index -= 1
                prev_end = min(end_time, prev_end)  # Remove the screening that ends later
    max_len = len(max(sorted_unique_film_tuples, key=len))  # Length of longest combination
    optimal_watchlist = [combination for combination in sorted_unique_film_tuples if len(combination) == max_len]
    return optimal_watchlist


def main() -> None:
    file_name = 'film_objects.dat'
    film_list_file_exists = os.path.exists(file_name)
    if not film_list_file_exists:
        film_list = generate_film_list(file_name=file_name)
        save_film_list(film_list=film_list, dst_file_name=file_name)
    else:
        film_list = load_film_list(src_file_name=file_name)
    
    print_film_list(film_list)
    user_film_dict = get_user_film_dict(film_list)
    
    print_film_dict(user_film_dict)

    date_list = get_date_list()
    print_date_list(date_list)
    user_date_dict = get_user_date_dict(date_list)
    
    # This might not be needed
    curr_user = User(film_dict=user_film_dict,
                     date_dict=user_date_dict)

    user_film_list = convert_film_dict_to_list(user_film_dict)
    unique_films_tuples = create_unique_film_list(user_film_list)
    # print_unique_films_tuples(unique_films_tuples=unique_films_tuples)
    sorted_unique_film_tuples = sort_combination_by_start_time(unique_films_tuples)
    nonoverlapping_screenings = get_optimal_watchlist(sorted_unique_film_tuples)
    print_unique_films_tuples(nonoverlapping_screenings)

if __name__ == '__main__':
    main()
