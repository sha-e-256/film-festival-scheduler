#!/usr/bin/env python3

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as ec
from webdriver_manager.firefox import GeckoDriverManager
from festival import Film, Screening, User
from datetime import date, datetime, timedelta
import pickle
import os
from collections import defaultdict
import itertools
from typing import List, Generator

def get_user_film_dict(film_dict: list[Film]) -> defaultdict:
    user_film_dict = defaultdict(set)
    print('--Select Films--')
    while True:
        upper_bound = len(film_dict)
        try:
            msg = f'Enter a number 1 to {upper_bound} (Enter -1 to exit): '
            user_film_index = int(input(msg))
            # Validate input
            if user_film_index in range(1, upper_bound + 1):
                user_film_dict[user_film_index - 1] = \
                    film_dict[user_film_index - 1]
                # usr_film_list is a set so not duplicates will be added
                msg = f'Added film: {film_dict[user_film_index - 1].film_name}'
                print(msg)
            elif user_film_index == -1:
                if len(user_film_dict) != 0:
                    break
                else:
                    print('You did not select any films. Please try again')
            else:
                print('Invalid input. Please try again.')
        except ValueError:
            print('Invalid input. Please try again')

    return user_film_dict

def get_user_date_dict(date_list: List[date]) -> defaultdict:
    user_date_dict = defaultdict(set)
    print('--Select Dates:--')
    while True:
        upper_bound = len(date_list)
        try:
            msg = f'Enter a number 1 to {upper_bound} (Enter -1 to exit): '
            user_date_index = int(input(msg))
            # Validate input
            if user_date_index in range(1, upper_bound + 1):
                user_date_dict[user_date_index - 1] = \
                    date_list[user_date_index - 1]
                msg = f'Added date: {date_list[user_date_index - 1]}.'
                print(msg)
            elif user_date_index == -1:
                if len(user_date_dict) != 0:
                    break
                else:
                    print('You did not select any dates. Please try again.')
            else:
                print('Invalid input. Please try again.')
        except ValueError:
            print('Invalid input. Please try again')

    return user_date_dict

def date_generator() -> Generator[date, None, None]:
    start_date = date(2022, 10, 27)
    end_date = date(2022, 11, 6)
    delta = timedelta(days=1)  # Increment iteration by one day
    while (start_date <= end_date):
        yield start_date
        start_date += delta

def print_date_dict(date_dict: defaultdict(set)) -> None:
    print('--Dates:--')
    for index, date in enumerate(date_dict.values()):
        print(f'[{index+1:03d}]: {date_dict[index]}')

def get_date_dict() -> defaultdict:
    date_dict = defaultdict(set)
    for index, date in enumerate(date_generator()):
        date_dict[index] = date
    return date_dict

def print_film_dict(film_dict: defaultdict(set)) -> None:
    # film_dict is being read as a list even though it is saved as a dict...
    print('--Films:--')
    for index, film in enumerate(film_dict):
        print(f'[{index+1:03d}]: {film.film_name}')
        # 03d: 3 digits pad with zeros

def print_user_film_dict(user_film_dict: defaultdict(set)) -> None:
    print('--Watchlist:--')
    [print(user_film.film_name) for user_film in user_film_dict.values()]

def save_film_dict(film_dict: defaultdict(set), dst_file_name: str) -> None:

    with open(file=dst_file_name, mode="wb") as file:
        pickle.dump(obj=film_dict, file=file)
        file.close()

def load_film_dict(src_file_name: str) -> defaultdict:

    with open(file=src_file_name, mode="rb") as file:
        film_dict = pickle.load(file=file)
    file.close()
    return film_dict

def generate_film_dict(file_name: str) -> defaultdict:
    film_dict = defaultdict(set)  # Create a list of Film objects
    screening_dict = defaultdict(set)  # Create a list of Screening objects
    
    browser = webdriver.Firefox(executable_path=GeckoDriverManager().install())
    browser.get('https://windsorfilmfestival.com/')
    film_list_button = browser.find_element(by=By.PARTIAL_LINK_TEXT,
                                    value='Films & Tickets')
    film_list_button.click()

    # After clicking, wait 5 s (5000 ms) for the site to load
    # Locator accepts a tuple as an arguement
    film_data_list = WebDriverWait(browser,
                                   5000).until(ec.presence_of_all_elements_located(locator=(By.XPATH,
                                                                                            "//div[@class='film-content']")))
    for film_data_index, film_data in enumerate(film_data_list):
        film_name_element = film_data.find_element(by=By.XPATH,
                                        value="./h2")  # . searches the child of
                                                       # the current node
        film_name = film_name_element.text
        screening_list = film_data.find_elements(by=By.XPATH,
                                                    value=".//div[@class='film-screen']")
        for screening_index, screening in enumerate(screening_list):
            screening_str = screening.text
            screening_str_list = screening_str.split('\n')
            
            screening_start_time_str = film_screen_str_list[-1]
            screening_start_time = datetime.strptime(screening_start_time_str, 
                                                     '%I:%M %p')
            
            film_length = 100  # Hardcode for now
            
            screening_end_time = screening_start_time + timedelta(minutes=film_length)
            
            screening_date_str = screening_str_list[0]
            screening_date = datetime.strptime(screening_date_str,
                                        '%a %b %d').date()  
            # Year defaults to 1899; change to 2022
            screening_date_correct_year = screening_date.replace(2021)
            
            screening_location = screening_str_list[1]

            # Make a Screening object
            curr_screening = Screening(screening_start_time,
                                    screening_end_time,
                                    screening_date_correct_year,
                                    screening_location)
            screening_dict[screening_index] = curr_screening

        # Make a Film object
        curr_film = Film(film_name, screening_dict)
        film_dict[film_data_index] = curr_film
        screening_dict.clear()  # Empty the dict of screenings
        
        '''
        moreInfo_button = filmData.find_element(by=By.PARTIAL_LINK_TEXT,
                                                value='MORE INFO')
        moreInfo_button.click()
        film_extras = WebDriverWait(browser, 4999).until(ec.presence_of_all_elements_located(locator=(By.XPATH,
                                                                                                            "//div[@class='film-extras']")))
        film_extras_str = film_extras[-1].text
        film_length = film_extras_str.split('\n')[-2]
        '''
    browser.quit()
    return film_dict

def convert_date_dict_to_list(date_dict: defaultdict(set)) \
    -> List[date]:

    date_list = [date for date in date_dict.values()]
    return date_list

def convert_film_dict_to_list(film_dict: defaultdict(set)) \
    -> List[List[tuple[str, Screening]]]:
    '''
    Convert the dict into a list of tuples such that each tuple contains
    the name of the film, and the Screening object; this is done so that the
    name of the film that a Screening belongs to is preserved after the
    cartesian product is generated.
    '''
    film_tuple_list = []
    # Each tuple contains the film name and one screening
    for film in film_dict.values():
        film_tuple = [(film.film_name, film_screening) \
                        for film_screening in film.film_screenings]
        film_tuple_list.append(film_tuple)
    return film_tuple_list

def create_unique_film_list(film_tuple_list: List[List[tuple[str, Screening]]]) \
    -> List[tuple[tuple[str, Screening]]]:
    '''
    Return the cartesian product such that each combination the viewing the 
    films only contains one screening for each film.
    '''
    # This method a list of tuples of tuples; not a list of lists of tuples
    unique_film_tuple_list = list(itertools.product(*film_tuple_list))
    return unique_film_tuple_list

def print_optimal_watchlist(unique_films_tuples: \
    List[list[tuple[str, Screening]]]) -> None:
    print('--Watchlist with Optimal Viewing Schedule:--')
    for i, combination in enumerate(unique_films_tuples):
        print(f'--Combination {i + 1}--')
        for film in combination:
            print(f'''\
Film Name: {film[0]}
Film Screening: {film[1].__str__()}\
            ''')

def sort_list_by_start_time(unique_film_tuple_list: \
    List[tuple[tuple[str, Screening]]]) -> List[List[tuple[str, Screening]]]:
    '''
    Sort the combination of films in the list of film tuples by the
    start time of the screenings.
    '''
    sorted_unique_film_tuples = []
    for combination in unique_film_tuple_list:
        combination_list = list(combination)

        # Sort by the screening start time using the lambda function
        # The second element in the tuple is the Screening objects 
        combination_list.sort(key=lambda x: x[1].screening_time_start) 
        sorted_unique_film_tuples.append(combination_list)
    return sorted_unique_film_tuples

def get_optimal_watchlist(combination_list: \
    List[List[tuple[str, Screening]]]) \
    -> List[List[tuple[str, Screening]]]:
    '''
    Return all combinations of films where none of the films in each
    combination are overlapping. 
    '''
    for comb in combination_list:
        # Start at the first tuple in the combination list
        # The second element in the tuple is the Screening object
        prev_end = comb[0][1].screening_time_end
        # Compare current tuple against the rest of the tuples
        # Start at the second tuple in the combination list
        for index, film_tuple in enumerate(list(comb[1:])):  # Iterate copy
            start_time, end_time = (film_tuple[1].screening_time_start,
                                    film_tuple[1].screening_time_end)
            # Check if the next film starts after the first film
            # If the movies are on different dates, they do not overlap
            curr_screening_date = film_tuple[1].screening_date
            prev_screening_date = comb[index][1].screening_date
            if (start_time >= prev_end or \
                curr_screening_date != prev_screening_date): 
                prev_end = end_time  # No overlap; check the next film
            else:
                # Remove the screening that ends later
                comb.remove(film_tuple)
                prev_end = min(end_time, prev_end)
    
    # Amount of films in the combination w/ the most films
    max_len = len(max(combination_list, 
                      key=len))
    optimal_watchlist = [comb for comb in \
        combination_list if len(comb) == max_len]
    return optimal_watchlist


def main() -> None:
    file_name = 'film_objects.dat'
    film_objects_file_exists = os.path.exists(file_name)
    if not film_objects_file_exists:
        film_dict = generate_film_dict(file_name=file_name)
        save_film_dict(film_dict=film_dict, 
                       dst_file_name=file_name)
    else:
        film_dict = load_film_dict(src_file_name=file_name)

    date_dict = get_date_dict()
    print_date_dict(date_dict)
    user_date_dict = get_user_date_dict(date_dict)
    user_date_list = convert_date_dict_to_list(user_date_dict)

    print_film_dict(film_dict)
    user_film_dict = get_user_film_dict(film_dict)
    print_user_film_dict(user_film_dict)
    
    user_film_list = convert_film_dict_to_list(user_film_dict)
    unique_user_film_list = create_unique_film_list(user_film_list)
    sorted_unique_user_film_list = \
        sort_list_by_start_time(unique_user_film_list)
    nonoverlapping_user_film_list = \
        get_optimal_watchlist(sorted_unique_user_film_list)
    print_optimal_watchlist(nonoverlapping_user_film_list)

if __name__ == '__main__':
    main()
